/*
不同路径增加难度版本，带有障碍
示例 1:

输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
	  输出: 2
	  解释:
	  3x3 网格的正中间有一个障碍物。
	  从左上角到右下角一共有 2 条不同的路径：
	  1. 向右 -> 向右 -> 向下 -> 向下
	  2. 向下 -> 向下 -> 向右 -> 向右


*/
#include<iostream>
#include<vector>
using namespace std;
//解法与之前的类似，只需要将障碍物处的路径数设置为0，那么当前格子（无障碍）的路径数为其左方的路径数与上方路径数的和
class Solution {
public:
	long int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		int m = obstacleGrid.size();
		if (m==0)
		{
			return 0;
		}
		int n = obstacleGrid[0].size();
		if (n==0)
		{
			return 0;
		}
		//构建二维数组nums,nums[m][n]代表m,n位置处的路径数
		long int**nums = new long int*[m];
		for (int i = 0; i < m; i++)
		{
			nums[i] = new long int[n];
		}
		if(obstacleGrid[0][0]!=1 && obstacleGrid[m - 1][n - 1]!=1) //起点和终点都不是障碍
		{
			nums[0][0] = 1;
		}
		else
		{
			return 0;
		}
		
		//初始化第一行，如果该位置前方不为障碍，那么其路径数为其左方的格子的路径数，因为只能向右或者向下走
		for (int i = 1; i < n; i++)
		{
			if (obstacleGrid[0][i]!=1)
			{
				nums[0][i] = nums[0][i - 1];
			}
			else
			{
				nums[0][i] = 0;
			}
		}
		//初始化第一列，道理同上
		for (int j = 1; j < m; j++)
		{
			if (obstacleGrid[j][0]!=1)
			{
				nums[j][0] = nums[j - 1][0];
			}
			else
			{
				nums[j][0] = 0;
			}
		}

		for (int i = 1; i < m; i++)
		{
			for (int j = 1; j < n; j++)
			{
				if (obstacleGrid[i][j]!=1)
				{
					nums[i][j] = nums[i - 1][j] + nums[i][j - 1];
				}
				else
				{
					nums[i][j] = 0;
				}
			}
		}
		return nums[m - 1][n - 1];
	}
};
int main()
{
	vector<vector<int>> a = { {0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},{0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0},{1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1},{0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0},{0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0},{1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0},{0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0},{0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0},{0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},{1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1},{0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0},{0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0},{0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1 }, { 1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0 }, { 0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1 }, { 0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1 }, { 1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0 }, { 0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1 }, { 0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0 } };
	Solution test;
	int road=test.uniquePathsWithObstacles(a);
	cin.get();
}